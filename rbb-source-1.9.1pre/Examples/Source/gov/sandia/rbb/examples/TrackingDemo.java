/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package gov.sandia.rbb.examples;

import gov.sandia.rbb.ui.timeline.RBBEventTimeline;
import gov.sandia.rbb.Event;
import gov.sandia.rbb.RBB;
import gov.sandia.rbb.Tagset;
import gov.sandia.rbb.Timeseries;
import static gov.sandia.rbb.Tagset.TC;
import gov.sandia.rbb.impl.h2.statics.H2STimeseries;
import gov.sandia.rbb.ui.DrawTimeseries;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;
import java.sql.SQLException;
import static gov.sandia.rbb.RBBFilter.*;

/**
 * This demo simulates an application in which a number of Entities are moving
 * around and being detected by a sensor as Tracks.
 * <P>
 * There are 2 different types of Entities (circles and triangles, both drawn in black)
 * and the task of the hypothetical user is to accurately label them (with a yellow Track icon of matching shape).
 * This is done with trackLabel=<label>,prevTrackID=<id> events, which specify that the track was given a label
 * for the duration of the trackLabel event.  Upon creation, a trackLabel=unlabeled event is created, and
 * persists until the hypothetical user labels the event.
 * <p>
 * If an incorrect label is assigned, the track is considered Mislabeled.
 *<p>
 * The tracking sensor is assumed to be imperfect, so the Tracks do not
 * perfectly reflect the Entities:
 *<p>
 * 1. An error random variable is added to all Tracks<br>
 * 2. There are spurious Tracks (that donâ€™t correspond to any Entity)<br>
 * 3. There are missing tracks (an entity has no corresponding Track)<br>
 *<p>
 * Entities (i.e. ground truth) are displayed in black.
 * Tracks (i.e. estimates generated by the tracking system) are displayed in yellow.
 *
 * @author rgabbot
 */
public class TrackingDemo {
    static final double duration = 600.0; // 10 mins
    private static Random rand = new Random();

    public static void main(String[] args) {
        try
        {
            String path = "/gov/sandia/rbb/examples/resources/shapes/";
            String rbbURL = "jdbc:h2:tcp:localhost/mem:TrackingDemo"; // default, may be overridden if last arg is a jdbc:
            
            if(args.length > 1)
                throw new Exception("Only 1 arg (a URL) is accepted");
            
            if(args.length > 0)
                rbbURL = args[0];
                
            ArrayList<String> drawArgs = new ArrayList<String>(Arrays.asList(
                "-server",
                "-create",
                "-noDots",
                "-maxTime", Integer.toString((int)duration),

                "-filterTags", "dataType=position",
                "-filterTags", "testType=Undetected_Entity,dataType=position",
                "-filterTags", "testType=Correctly_Labeled_Entity,dataType=position",
                "-filterTags", "testType=Mislabeled_Entity,dataType=position",
                "-filterTags", "testType=Unlabeled_Entity,dataType=position",
                "-filterTags", "testType=Mislabeled_Spurious_Track,dataType=position",
                "-filterTags", "testType=Spurious_Track,dataType=position",
                "-filterTags", "testType=Changing_Labels,dataType=position",

            //    "-label", "trackID",

                "-eventTags", "type=circle,supertype=entity,color=black",
                "-eventTags", "type=triangle,supertype=entity,color=black",

                "-eventTags", "label=circle,supertype=track,color=yellow",
                "-eventTags", "label=triangle,supertype=track,color=yellow",
                "-eventTags", "supertype=track,color=yellow",

                "-gatherTags", rbbURL, "trackID", "trackLabel",

                "-icon", "type=circle", path+"BlackCircle_small.png",
                "-icon", "type=triangle", path+"BlackTriangle_small.png",

                "-icon", "trackLabel=circle", path+"YellowCircle_small.png",
                "-icon", "trackLabel=triangle", path+"YellowTriangle_small.png",
                "-icon", "trackLabel=unlabeled", path+"YellowQuestion_small.png",

                "-icon", "", path+"GreenSquare_small.png",
                
                rbbURL));

            DrawTimeseries draw = new DrawTimeseries(drawArgs.toArray(new String[0]));

            RBBEventTimeline.main(new String[]{
                "-endTime", "300000",
                "-multiTimelineTagset", "type=AEMASE_flag,MLModel",
                rbbURL});

            // draw.rbb.deleteEvents(TC("type=AEMASE_flag"));
//
            if(Event.find(draw.rbb.db(), byTags("color")).length == 0) // scenrio is empty - generate some entities!
                makeScenario(draw.rbb);

            ///// find mis-labeled entities.
            if(Event.find(draw.rbb.db(), byTags("alreadySearchedForMislabeledTracks=true")).length > 0) {
                System.err.println("Not searching for mislabeled events - was already done");
            }
            else {
                for(Event labelEvent : Event.find(draw.rbb.db(), byTags("trackLabel"))) {
                    final String label = labelEvent.getTagset().getValue("trackLabel").toLowerCase();
                    if(label.equals("unlabeled"))
                        continue; // this is not a manual labeling; just the default / unlabeled track.

                    //// find all nearby entities to see if any of them qualify for this label.
                    // first get the track that has been given the label, and get its position.
                    final Integer trackID = Integer.parseInt(labelEvent.getTagset().getValue("trackID"));
                    // get the current position of that track.
                    final Double labelTime = labelEvent.getStart();
                    final Timeseries[] track = Timeseries.findWithSamples(draw.rbb.db(), byTags("dataType=position,supertype=track,trackID="+trackID), byTime(labelTime, labelTime));
                    if(track.length!=1) {
                        System.err.println("Error: each label must correspond to one track, but label (RBB ID="+labelEvent.getID()+") with trackID="+trackID+" corresponds to " + track.length + " of them");
                        continue;
                    }
                    // find any nearby entity that matches.
                    // findNearest ResultSet: ID, START_TIME, END_TIME, TAGS, DATA_SCHEMA, DATA_TABLE, X, DIST
                    final ResultSet rs = H2STimeseries.findNearest(draw.rbb.db(), "dataType=position,supertype=entity,type="+label, track[0].valueLinear(labelTime), labelTime, null, 30.0, 100);
                    if(rs.next()) { // yes, at least one matching entity was found for the label.
                        // see if this entity is of a type that the label would be valid.
                        // System.err.println(text + "Matching entity " + rs.getLong("ID") + " found.");
                        continue;
                    }

                    // The following code is for the more complex case where a label may be appropriate for more than one type of entity.
    //                final ResultSet rs = H2STimeseries.findNearest(draw.rbb.db(), new Object[]{"dataType","position","supertype","entity"}, track[0].valueLinear(labelTime, null), labelTime, 30.0, 100);
    //                while(rs.next()) {
    //                    // see if this entity is of a type that the label would be valid.
    //                    final Tagset entityTags = new Tagset((Object[])rs.getArray("TAGS").getArray());
    //                    if(entityTags.getValue("type").equalsIgnoreCase(label)) {
    //                        System.err.println("Matching entity " + rs.getLong("ID") + " found.");
    //                        continue TRACKLOOP; // this entity justifies the use of the label.
    //                    }
    //                }

                    // if we got here, a label without justification was found.
                    // flag it.
                    // String text = "Wrong label (" + label + ") on track " + trackID + " of type " + track[0]. + " at time " + labelTime + " (testType: "+ labelEvent.getTagset().getValue("testType")+")... ";
                    String text = "Track " + trackID + " was incorrectly labeled \"" + label + "\"";
                    new Event(draw.rbb.db(), labelTime, labelTime+1, new Tagset("type=AEMASE_flag,MLModel=Mislabeled Tracks,author=Automatic,text="+text));
                }
                new Event(draw.rbb.db(), 0.0, 0.0, TC("alreadySearchedForMislabeledTracks=true"));
            }

            //// find unlabeled entities
            if(Event.find(draw.rbb.db(), byTags("alreadySearchedForUnlabeledTracks=true")).length > 0) {
                System.err.println("Not searching for unlabeled events - was already done");
            }
            else {
                String q = "select * from rbb_find_events('trackLabel=unlabeled', null, null, null) where end_time-start_time > 30;";
                ResultSet rsUnlabeled = draw.rbb.db().createStatement().executeQuery(q);
                // ID  	START_TIME  	END_TIME  	TAGS
                while(rsUnlabeled.next()) {
                    Tagset tags = new Tagset((Object[])rsUnlabeled.getArray("TAGS").getArray());
                    final double start = rsUnlabeled.getDouble("START_TIME");
                    final double end = rsUnlabeled.getDouble("END_TIME");
                    final double duration = end-start;
    //                final String text = "Track " + tags.getValue("trackID") + " (testType: "+ tags.getValue("testType") + ") was unlabeled for " + duration + " seconds.";
                    final String text = "Track " + tags.getValue("trackID") + " wasn't labeled quickly enough (" + (int) duration + " seconds)";
                    System.err.println(text);
                    new Event(draw.rbb.db(), start, start+1, TC("type=AEMASE_flag,MLModel=Unlabeled Tracks,author=Automatic,text="+text));
                }
                new Event(draw.rbb.db(), 0.0, 0.0, TC("alreadySearchedForUnlabeledTracks=true"));
           }

            // must set visible only after making the scenario, because that processing is
            // done by the main thread instead of the GUI thread, and setVisible(true) starts
            // receiving messages from the GUI thread.  Running both concurrently causes problems.
            draw._frame.setVisible(true);
        }
        catch (Exception ex)
        {
            System.err.println("TrackingDemo.java Exception: " + ex.toString());
        }
    }

    /**
     * Create a Session RBB with the following characteristics:
     * 1) Time is accelerated so movement is obvious and mini-scenarios play out in watchable time
     * 2) Time is slow enough that a person can draw a new entity to fly in concert with scripted ones.
     * 3) A variety of entity types are used.
     * 4) Several different models could be defined.
     */
    static void makeScenario(final RBB rbb) throws SQLException {

        final double timestep = 1;
        final float twopi = 2.0f * 3.1415927f;
        final int width = 1600;
        final int height = 1050;
        Timeseries ts = null;

        Timeseries ownship = new Timeseries(rbb, 2, 0.0, TC("type=ownship,dataType=position"));
        ownship.add(rbb, 0.0, 40.0f, height/2.0f);
        ownship.add(rbb, duration, 40.0f, height/2.0f);

        // perl -e 'for $i(1..8){print "makeEntity(rbb, ",int(rand(1600)),",", int(rand(1050)),", ",int(rand(1600)),",", int(rand(1050)),", ",int(5+rand(5)),", \"circle\", null);\n"}'

        // Undetected_Entity... no label
        String testType="Undetected_Entity";
        makeEntity(rbb, testType, 293,711, 60,415, 6, "circle");
        makeEntity(rbb, testType, 1228,752, 269,191, 8, "circle");
        makeEntity(rbb, testType, 740,517, 303,610, 6, "circle");
        makeEntity(rbb, testType, 617,109, 396,149, 7, "circle");
        makeEntity(rbb, testType, 561,58, 1406,9, 9, "triangle");
        makeEntity(rbb, testType, 598,151, 1074,343, 8, "triangle");
        makeEntity(rbb, testType, 161,754, 368,436, 5, "triangle");
        makeEntity(rbb, testType, 534,801, 567,470, 5, "triangle");

        // Correctly_Labeled_Entity
        testType="Correctly_Labeled_Entity";
        makeEntity(rbb, testType, 410,797, 1298,166, 9, "circle", "circle");
        makeEntity(rbb, testType, 867,94, 375,632, 8, "circle", "circle");
        makeEntity(rbb, testType, 137,383, 1082,730, 6, "circle", "circle");
        makeEntity(rbb, testType, 147,839, 316,91, 6, "circle", "circle");
        makeEntity(rbb, testType, 219,590, 468,133, 9, "triangle", "triangle");
        makeEntity(rbb, testType, 436,801, 465,482, 6, "triangle", "triangle");
        makeEntity(rbb, testType, 652,1017, 736,763, 7, "triangle", "triangle");
        makeEntity(rbb, testType, 622,562, 1371,643, 9, "triangle", "triangle");

        // Mislabeled_Entity
        testType="Mislabeled_Entity";
        makeEntity(rbb, testType, 1570,758, 110,631, 9, "triangle", "circle");
        makeEntity(rbb, testType, 422,33, 197,118, 8, "triangle", "circle");
        makeEntity(rbb, testType, 1306,1025, 1580,154, 7, "triangle", "circle");
        makeEntity(rbb, testType, 249,469, 1311,318, 9, "triangle", "circle");
        makeEntity(rbb, testType, 570,91, 807,647, 8, "circle", "triangle");
        makeEntity(rbb, testType, 1334,369, 183,605, 8, "circle", "triangle");
        makeEntity(rbb, testType, 2,813, 1306,767, 6, "circle", "triangle");
        makeEntity(rbb, testType, 229,252, 954,188, 9, "circle", "triangle");

        // Unlabeled_Entity
        testType="Unlabeled_Entity";
        makeEntity(rbb, testType, 694,291, 432,637, 8, "circle", "unlabeled");
        makeEntity(rbb, testType, 1524,494, 885,163, 5, "circle", "unlabeled");
        makeEntity(rbb, testType, 915,533, 1391,568, 9, "circle", "unlabeled");
        makeEntity(rbb, testType, 770,839, 1407,164, 9, "circle", "unlabeled");
        makeEntity(rbb, testType, 1591,926, 990,530, 7, "triangle", "unlabeled");
        makeEntity(rbb, testType, 712,637, 1198,546, 5, "triangle", "unlabeled");
        makeEntity(rbb, testType, 220,466, 1548,837, 7, "triangle", "unlabeled");
        makeEntity(rbb, testType, 1342,793, 597,688, 7, "triangle", "unlabeled");

        // Mislabeled_Spurious_Track
        testType="Mislabeled_Spurious_Track";
        makeEntity(rbb, testType, 18,671, 1221,969, 6, null, "circle");
        makeEntity(rbb, testType, 113,285, 1416,6, 9, null, "circle");
        makeEntity(rbb, testType, 203,222, 236,661, 8, null, "triangle");
        makeEntity(rbb, testType, 564,919, 90,176, 7, null, "triangle");
        
        // Spurious_Track
        testType="Spurious_Track";
        makeEntity(rbb, testType, 1354,610, 663,429, 6, null, "unlabeled");
        makeEntity(rbb, testType, 990,640, 614,602, 5, null, "unlabeled");
        makeEntity(rbb, testType, 770,824, 270,1014, 5, null, "unlabeled");
        makeEntity(rbb, testType, 1074,429, 224,844, 9, null, "unlabeled");

        ////// unlike the previous, this isn't a test of one thing, it's a grab-bag
        // Changing_Labels
        testType="Changing_Labels";
        makeEntity(rbb, testType, 1203,518, 163,573, 5, "circle", "circle", "triangle", "unlabeled");
        makeEntity(rbb, testType, 204,645, 89,979, 9, "circle", "triangle", "circle", "triangle");
        makeEntity(rbb, testType, 660,294, 219,768, 7, "circle", "triangle", "circle");

    }

    private static int prevTrackID=0;
    
    private static void makeEntity(RBB rbb, String testType, int x1, int y1, int x2, int y2, int speed, String type, String... labels) throws SQLException {
        double start = 0.0;
        double end = start+distance(x1,y1,x2,y2)/speed;

        Timeseries entity = new Timeseries(start, end, TC("dataType=position,supertype=entity,type="+type+",testType="+testType), 2);
        entity.add(start, (float)x1, (float)y1);
        entity.add(end, (float)x2, (float)y2);
        entity.setEnd(end);        
        
        // if the type is null, it's a spurious track, i.e. there's nothing really there.
        if(type != null)
            entity.persist(rbb.db());

        if(labels.length==0)
            return; // undetected

        final double trackStart = start+rand.nextDouble()*5; // when entity appears it takes awhile to register in the tracker
        final double trackEnd = end+rand.nextDouble()*5; // when the entity disappears it takes a few moments for the track to disappear.
        Timeseries track = new Timeseries(rbb, 2, trackStart, TC("dataType=position,supertype=track,trackID="+(++prevTrackID)+",testType="+testType));
        track.add(rbb, trackStart, noisyPosition(entity.extrapolateValueLinear(trackStart)));
        track.add(rbb, trackEnd, noisyPosition(entity.extrapolateValueLinear(trackEnd)));
        track.setEnd(rbb.db(), trackEnd);

        // the track is initially, automatically unlabeled.
        double labelTime = trackStart;
        Event labelEvent = new Event(rbb.db(), labelTime, 99999.9, TC("trackLabel=unlabeled,trackID="+prevTrackID+",testType="+testType));

        // then after a fairly short pause, the operator responds and applies a label manually
        if(!labels[0].equals("unlabeled")) {
            labelTime += 4+rand.nextDouble()*10;
            labelEvent.setEnd(rbb.db(), labelTime); // old label ends when new starts.
            labelEvent = new Event(rbb.db(), labelTime, 99999.9, TC("trackLabel="+labels[0]+",trackID="+prevTrackID+",testType="+testType));
        }

        // each of the remaining labels (if any) takes about 1/n of the remaining time.
        final double labelDuration = (trackEnd-labelTime)/labels.length;
        for(int i = 1; i < labels.length; ++i) {
            labelTime += labelDuration;
            labelEvent.setEnd(rbb.db(), labelTime); // old label ends when new starts.
            labelEvent = new Event(rbb.db(), labelTime, 99999.9, TC("trackLabel="+labels[i]+",trackID="+prevTrackID+",testType="+testType));
        }

        labelEvent.setEnd(rbb.db(), trackEnd); // label goes away with track.

    }

    /*
     * This is supposed to simulate tracking error by adding noise to a position.
     * But to make it easy to look at we just add an offset to the x coordinate.
     */
    private static Float[] noisyPosition(Float[] x) {
        Float[] y = Arrays.copyOf(x, x.length);
        y[0] += 10.0f;
        return y;
        //                return x + rand.nextFloat() * 20.0f-10.0f;
    }

    private static double distance(float x1, float y1, float x2, float y2) {
        return (float) Math.sqrt(Math.pow(x2-x1, 2)+Math.pow(y2-y1, 2));
    }
}
//
//class UnlabeledEntity extends MLModel {
//
//    @Override
//    public MLFeatureExtractor getPredictionFE() {
//        return new DistanceFE("Range", "Ownship_Position", "Unlabeled_Entity_Position", DistanceFE.DistanceType.SCALAR,
//            new ProblemAgeFE("Duration",
//            null));
//    }
//
//    @Override
//    public String[] getInputNames(Mode op)
//    {
//        return new String[] { "Ownship_Position", "Unlabeled_Entity_Position" };
//    }
//
//    @Override
//    public String[] getDefaultPredictorNames()
//    {
//        return new String[] { "Range", "Duration" };
//    }
//
//    @Override
//    public MLFeatureExtractor getTrainingFE()
//        throws Exception
//    {
//        throw new UnsupportedOperationException("Not supported yet.");
//    }
//
//}
